<html>
	<head>
	  <script src="../src/bss-1.2.5.js"></script>
		<style>
			span{
				font-size: 1.5em;
			}
			ul{
				list-style : none;
				padding-left : 1em;
				margin: .3em 0;
				cursor: pointer;
				user-select: none;
			}
			ul.closed > ul, ul.closed > li{
				display: none;
			}
			ul.closed::before{
				content : "\1F4C1";
			}
			ul::before{
				content : "\1F4C2";
				font-size: 2em;
				font-weight: bold;
				color: brown;
				margin-right: .3em;
			}
			li{
				padding-left : 2em;
				margin: .3em 0;
				user-select: none;
			}
			
			li::before{
				content: "\1F5CE";
				color: navy;
				font-size: 2em;
				font-weight: bold;
				margin-right: .3em;
			}
		</style>
		<template id="TEMPL">
			<ul name="fakefsview">
				<span></span>
				<li><span></span></li>
				<ul>
					<span></span>
					<li><span></span></li>
				</ul>
			</ul>			
		</template>
	</head>
	<body>
		<h1>Example 7: Custom targets and arbitrarily nested structures</h1>
		<p>Shows new feature of v. 1.2.4 where edi-function can be used to provide custom nodesets for binding instead of relying only on css-selectors. Moreover the example demonstrates how segments of bss can be factored and applied recursively in order to bind to arbitrarily nested structures.</p>
		<hr/>
		<ul name="fakefsview"></ul>
		<script type="text/javascript">
			var fakefsdata = {
				"name" : "/", "type" : "dir",
				"content" : [
					{"name" : "tmp", "type" : "dir",
						"content" :[
							{"name" : "file1.txt", "type" : "file"},
							{"name" : "folder1", "type" : "dir", "content" : []}
						]
					},
					{"name" : "opt", "type" : "dir",
						"content" : [
							{"name" : "package.deb", "type" : "file"}
						]
					}
				]
			}
			var recursive_bss = [
				{
					//target nodes are only direct ul children which is impossible with css selectors
					target: e => Array.prototype.slice.call(e.children).filter(c=>c.nodeName.toLowerCase() === "ul"),
					in : (e,d,i) => { return d.content.filter(c=>c["type"] === "dir") },
					apply : (e,d,i) => { e.querySelector("span").textContent = d["name"] },
					recurse : (e,d,i) => recursive_bss,
					on_click : ev => { ev.target.classList.toggle("closed"); ev.stopPropagation()}
				},
				{
					//target nodes are only direct li children which is impossible with css selectors
					target: e => { return Array.prototype.slice.call(e.children).filter(c=>c.nodeName.toLowerCase() === "li")}, 
					in : (e,d,i) => { return d.content.filter(c=>c["type"] === "file") },
					apply : (e,d,i) => { e.querySelector("span").textContent = d["name"]}
				}
			]
			fakefs_bss = {
				template : "#TEMPL",
				target : "ul[name=fakefsview]",
				in: fakefsdata,
				apply : (e,d,i)=>{ e.querySelector("span").textContent = d["name"]},
				recurse : (e, d, i) => recursive_bss,
				on_click : ev => { ev.target.classList.toggle("closed"); ev.stopPropagation()}
			}
			BSS.polyfill() //in order to manage templates in older browsers and IE
			BSS.apply(fakefs_bss)
		</script>
</html>
